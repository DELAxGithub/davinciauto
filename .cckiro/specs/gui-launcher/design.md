# Design: Minimal GUI Launcher

## Approach Overview
Deliver the launcher in two iterations:
1. **Automator/AppleScript-based Launcher** (v0): Presents simple dialogs to capture script/output/API key, then invokes `davinciauto-cli` with appropriate flags. Zero Swift code; quick win for production adoption.
2. **SwiftUI Frontend (EditAutoApp-lite)** (v1): Reuse existing Swift components to provide a richer interface (self-check logs, keychain storage, progress view) while still calling the CLI as a subprocess.

Both variants keep the CLI as the source of truth for pipeline execution.

## Components

### Launcher Shell Script (`scripts/gui_launcher_run.sh`)
- Normalises environment variables (`DAVINCIAUTO_FFMPEG`, etc.).
- Calls `davinciauto-cli` with arguments generated by the GUI.
- Captures stdout/stderr to log file for support.

### Automator/AppleScript (v0)
- AppleScript app packaged into DMG (`resources/Launcher.app`).
- Sequence:
  1. Prompt for API key (optional). Store in temporary env or write to `~/.config/davinciauto-cli`. Later handoff to SwiftUI.
  2. Prompt for input script (`choose file`).
  3. Prompt for output folder (`choose folder`).
  4. Offer radio buttons: `Self-Check`, `Fake-TTS`, `Full Run`.
  5. Execute shell script and show completion dialog, optionally open output folder.

### SwiftUI Launcher (v1)
- New target `DavinciAutoLauncher` inside existing Xcode project.
- Screens:
  - **Setup Tab:** Self-check status, “Run Self-Check” button, log view.
  - **API Keys Tab:** SecureField for key, buttons to save/delete (reuse `KeychainService`).
  - **Run Tab:** File pickers for script/output, provider dropdown, Fake-TTS toggle, run/stop buttons.
- Uses `ProcessExec` to call CLI with `--ffmpeg`/`--ffprobe` flags resolved via bundle.
- Log output displayed in a scrolling view; export button for support.

### Packaging
- Include Automator app + helper script under `resources/` and copy into DMG.
- For SwiftUI v1, integrate with existing codesign/notarize flow (reuse Python.framework & resources).

## Data Flow
1. User launches GUI → selects options.
2. GUI writes temp configuration (env + CLI args).
3. GUI invokes shell script → shell script runs CLI.
4. CLI outputs JSON/logs → shell script/GUI surfaces results to user.

## Risks & Mitigations
- **AppleScript UX limitations:** Provide clear instructions + fallback to Terminal commands in documentation.
- **Keychain conflicts:** When SwiftUI version lands, ensure it shares service identifiers with current Swift components.
- **Double packaging overhead:** Confirm DMG size impact is acceptable (Automator app is minimal).

